<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Dante Screen - Sender</title>
  <link rel="stylesheet" href="/styles.css" />
</head>
<body>
  <main>
    <h1>Dante Screen (Sender)</h1>
    <label>
      Room ID
      <input id="room" maxlength="24" />
    </label>
    <div class="buttons">
      <button id="start">Start Dante Screen</button>
      <button id="stop" disabled>Stop Dante Screen</button>
      <button id="copy" title="Copy viewer link">Copy viewer link</button>
    </div>
    <p id="status">Idle</p>
    <video id="preview" autoplay playsinline muted></video>
  </main>

  <script>
    const roomEl = document.getElementById('room');
    const startBtn = document.getElementById('start');
    const stopBtn = document.getElementById('stop');
    const copyBtn = document.getElementById('copy');
    const statusEl = document.getElementById('status');
    const preview = document.getElementById('preview');

    const DEFAULT_ROOM = 'live';
    const urlParams = new URLSearchParams(location.search);
    roomEl.value = urlParams.get('room') || DEFAULT_ROOM;

    let pc, ws, stream;

    function preferVideoCodec(sdp, codec) {
      try {
        const lines = sdp.split('\n');
        const mLineIndex = lines.findIndex(l => l.startsWith('m=video'));
        if (mLineIndex === -1) return sdp;
        const rtpmap = new Map();
        for (const l of lines) {
          const m = l.match(/^a=rtpmap:(\d+)\s+([^/]+)/);
          if (m) rtpmap.set(m[1], m[2].toUpperCase());
        }
        const parts = lines[mLineIndex].trim().split(' ');
        const header = parts.slice(0, 3);
        const payloads = parts.slice(3);
        const preferred = [];
        const others = [];
        for (const pt of payloads) {
          const name = (rtpmap.get(pt) || '').toUpperCase();
          if (name.includes(codec.toUpperCase())) preferred.push(pt); else others.push(pt);
        }
        lines[mLineIndex] = [...header, ...preferred, ...others].join(' ');
        return lines.join('\n');
      } catch { return sdp; }
    }

    function updateStatus(t){ statusEl.textContent = t; }

    function viewerLink(){
      const r = encodeURIComponent(roomEl.value.trim());
      const u = new URL(location.origin + '/viewer.html');
      u.searchParams.set('room', r);
      return u.toString();
    }

    copyBtn.onclick = async () => {
      try { await navigator.clipboard.writeText(viewerLink()); updateStatus('Viewer link copied'); }
      catch { updateStatus('Copy failed'); }
    };

    function connectWS() {
      return new Promise((resolve, reject) => {
        ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host);
        ws.onopen = () => { ws.send(JSON.stringify({ type: 'join', role: 'sender', room: roomEl.value.trim() })); resolve(); };
        ws.onerror = reject;
        ws.onmessage = async (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'answer') {
            await pc.setRemoteDescription(new RTCSessionDescription({ type: 'answer', sdp: msg.sdp }));
            updateStatus('Viewer connected');
          } else if (msg.type === 'ice-candidate' && msg.candidate) {
            try { await pc.addIceCandidate(msg.candidate); } catch {}
          } else if (msg.type === 'viewer-ready') {
            updateStatus('Viewer joined');
          } else if (msg.type === 'viewer-disconnected') {
            updateStatus('Viewer disconnected');
          }
        };
      });
    }

    async function startSharing() {
      const room = roomEl.value.trim();
      if (!room) return updateStatus('Enter a room ID');
      startBtn.disabled = true; roomEl.disabled = true;
      try {
        await connectWS();
        stream = await navigator.mediaDevices.getDisplayMedia({ video: { frameRate: 15 }, audio: true });
        preview.srcObject = stream;
        updateStatus('Dante Screen live');

        let iceServers = [{ urls: 'stun:stun.l.google.com:19302' }];
        try {
          const r = await fetch('/config');
          const cfg = await r.json();
          if (Array.isArray(cfg.iceServers)) iceServers = cfg.iceServers;
        } catch {}
        const forceRelay = (new URLSearchParams(location.search)).get('relay') === '1';
        pc = new RTCPeerConnection({ iceServers, iceTransportPolicy: forceRelay ? 'relay' : 'all' });
        // Add tracks as-is for maximum compatibility
        stream.getTracks().forEach(t => pc.addTrack(t, stream));

        pc.onicecandidate = (e) => {
          if (e.candidate) ws.send(JSON.stringify({ type: 'ice-candidate', candidate: e.candidate }));
        };

        let offer = await pc.createOffer();
        // Prefer VP8 to avoid black video on some mobile browsers
        const munged = preferVideoCodec(offer.sdp, 'VP8');
        offer = new RTCSessionDescription({ type: 'offer', sdp: munged });
        await pc.setLocalDescription(offer);
        ws.send(JSON.stringify({ type: 'offer', sdp: offer.sdp }));
        updateStatus('Live â€” copy viewer link to watch');
        stopBtn.disabled = false;

        stream.getVideoTracks()[0]?.addEventListener('ended', stopSharing);
      } catch (e) {
        console.error(e);
        updateStatus('Failed to start Dante Screen');
        startBtn.disabled = false; roomEl.disabled = false;
      }
    }

    function stopSharing() {
      stopBtn.disabled = true;
      try { stream?.getTracks().forEach(t => t.stop()); } catch {}
      try { pc?.close(); } catch {}
      try { ws?.close(); } catch {}
      pc = null; ws = null; stream = null;
      startBtn.disabled = false; roomEl.disabled = false;
      updateStatus('Dante Screen stopped');
    }

    startBtn.onclick = startSharing;
    stopBtn.onclick = stopSharing;
  </script>
</body>
</html>
